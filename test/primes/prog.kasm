# for functions: all arguments passed on the stack, ra is return code

# set up the stack
MOV $0x1000 rsp

# test cases
PUSH $197
PUSH $194
CALL try_case

PUSH $569
PUSH $564
CALL try_case

PUSH $1009
PUSH $998
CALL try_case

PUSH $1931
PUSH $1914
CALL try_case

# all cases pass
HLT

case_fail:
    ABRT
    HLT

try_case:
    # FIXME ridiculous hack
    POP rbp
    POP ra
    PUSH rbp

    PUSH ra
    CALL find_next_prime

    # FIXME ridiculous hack
    POP rbp
    POP rb
    PUSH rbp

    CMP rb ra
    JNZ case_fail
    RET

find_next_prime:
    # FIXME ridiculous hack
    POP rbp
    POP ra
    PUSH rbp
    find_next_prime_loop:
        STW $0x0500 ra
        PUSH ra
        MOV ra rbp
        CALL primetest
        TST ra
        LDW $0x0500 ra
        JNZ find_next_prime_out
        ADD $1 ra
        JMP find_next_prime_loop
    find_next_prime_out:
        RET

# Clobbers ra, rb, rbp
# arg1 = n, arg2 = m, ret = n mod m
modulo:
    # FIXME ridiculous hack
    POP rbp
    POP rb
    POP ra
    PUSH rbp

    modulo_loop:
        CMP ra rb
        JL modulo_out
        SUB rb ra
        JMP modulo_loop

    modulo_out:
        RET

# Clobbers ra, rb, rc, rd, rbp
# arg1 = n, ret = is_prime(n)
primetest:
    # FIXME ridiculous hack
    POP rbp
    POP rc
    PUSH rbp

    MOV $2 rd

    primetest_loop:
        CMP rd rc
        JE primetest_out

        PUSH rc
        PUSH rd
        CALL modulo
        TST ra
        # modulo returns 0 if rd divides rc
        JZ primetest_fail
        ADD $1 rd

        JMP primetest_loop

    primetest_out:
        MOV $1 ra
        RET

    primetest_fail:
        MOV $0 ra
        RET