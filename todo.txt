

  Where do we use floating levels?:
    * In the implementation of TST
    * In the implementation of the byte-store-with-zero instructions
    * During IO instructions which take a few cycles to complete

    - So, if we want we can remove, but I think this is a really bad idea if the design is to have all of these CMOS components passively connected and acting on clocks.



  REMAINING HARDWARE TO SIMULATE:






    * A jumper/soft flag to issue an NMI after every instruction? (so we can have debugging (over serial?) in the real thing!)
        - To implement this we basically just need a line which is `!CBIT_HNMI && !CBIT_INSTMASK` which triggers the interrupt,
          and the only thing we need to check is that this does not set a pending interrupt while an NMI is being serviced
          (i.e. that there isn't a window after the NMI is acked by the CPU but before CBIT_HNMI is set which causes the PIC
          to mark it pending a second time---since then we would get in a loop.)
        - But now that I think about it, I think this combination of flags will work directly?---try it!

        - Add a test; enable the jumper with a debug IO command, then have NMIs count the number of instructions in the test.






  Instruction/ucode design:

    * Compress ucode! (should we really do this anymore at this point?)

    * MOAR TESTS





  Assembler improvements:

    * Allow a const in either argument in e.g. a STW (but not e.g. LDW)

    *  Remove direct access to %rid in the assembler; at the moment the only legitimate usage is saving/restoring in an interrupt handler,
    and in this case we can just roll a custom version of PUSHFG/POPFG to also push/pop it? (actually, there might be
    some problem with decrementing RSP a second time during the push? I think the ALU will be able to do the math
    simultaneously instead?)




  VM UI:
    * Write a post-processor for the disassembler to try to collapse aliases.---this isn't super hard, just search
      for aliases which begin with the first actual opcode, and then continue checking ahead for matches.
            ---> It would probably be best to do this after loading and before executing the binary, so that
                 we don't get confused when we are in the middle of a few instructions all part of the same alias.


  In the VM:

    * (For below, really, how is the physical hardware implementation going to work compared to what we have now implementated?)
       In particular, there is no IO controller buffer at all right now, which works great for directly exposing registers,
       so investigate if this direct-method could work when we want to talk to something like a serial chip.

    * Also, for the IO bus use bus hold devices to decouple them, instead of having a silly intermediate IO controller register
  (but remember we want the IO modules to be able to asynchronously call in their results and move on with their lives)












HARDWARE:

  USE 74HC193 for COUNTERS!!!!

  Remember for designs:
    * Remember, BUS_A and BUS_B should both be pulled low.
    * WE ADDED HARDWARE INC AND DEC COMMANDS TO RSP. AND THE RSP INC/DEC MECHANISM IS COMPLEX, OCCURING A HALF CYCLE BEFORE (check the timings work out).
    * We are hardware latching the ucode in mod_ctl

    * PROHIBIT MOV %rx %rx in hardware (it would be undefined)
            -> I think what I had here was way too complex---just have an output signal to each register inhbit an input signal? Yeah, there are only 8.




  Bugs in current revisions:
  * ALU: the high bits of the switch connecting BUS_B
        to the ALU flags register float!!!!
    ALU: It also has two floating gates!!!

  Improvements for future revisions:
  * remove the zero registers from the REG module? (or, can we change the VM code so that we never use a pull-down behaviour?)
  * mod_alu: OR and AND are swapped physically on the board vs the mode signal numbers




  Need to think more:
  * Originally improvement thought, but then I remembered:
    mod_mem: allow 1-clock word reads and writes. -> If you have this, you can't write into RA using the address in RA---so forget it?


