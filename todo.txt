
SOFT/FIRMWARE:

  VM UI:
    * Write a post-processor for the disassembler to try to collapse aliases.---this isn't super hard, just search
      for aliases which begin with the first actual opcode, and then continue checking ahead for matches.
            ---> It would probably be best to do this after loading and before executing the binary, so that
                 we don't get confused when we are in the middle of a few instructions all part of the same alias.


  In the VM:
    * FIX THE BUS IN THE MEMORY UCODE STUFF (explained there in a fixme)


  Fix bug by moving the BUSMODE_X flag into one of the free spots in the CTL or GTRL actions, since they are only needed during byte-type operations

Also, for the IO bus use bus hold devices to decouple them, instead of having a silly intermediate IO controller register
(but remember we want the IO modules to be able to asynchronously call in their results and move on with their lives)



    * FLAG-ONLY versions of the ALU insts (we already value-only versions).

    * DEAL with the hardware design comment in the push_pop test

    * Allow a const in either argument in e.g. a STW (but not e.g. LDW)

    * Compress flags!


    * PROHIBIT MOV %rx %rx in software? (it would be a short)
            -> one way to prohibit this in hardware reasonably cheaply is to compare the IUn_I
               command 3 bits with the IUn_O 3 command 3 bits for each fixed ups---if they are equal, inhibit the input.



    * Space in the UCODE bits to support a very basic port-based IO interface
    (I think two ucode control bits, read and write (read will need two states, input port and output data), takes port from BUSA and data from BUSB)
            -> Implement a "wait" condition until the IO bus returns?


    * How are we going to do interrupts??? (I think another instmask---just to 0x1 instead of 0x0)
            -> 1. (MOV(BUSA) RIP RID | MOV(BUSB) RISP RIP)
            -> 2. MOV RIHP RIP (equivalent)
            -> (need to save flags, stack pointer (in a fixed location), old RIP stashed in RID,
                plus load new stack, save all registers, etc. in __code__ then)

            -> implement the interrupt code, and EOI signalling, using the IO bus.

            -> required new control features: RISP BUSB output

    * THUS, NEED A PUSH_FLAGS and POP_FLAGS instruction. Need 1 control bit/free action to support flags output. (already have input).


    * Does an ordinary NOP in some code cause a 1-uop stutter when REG_UC gets reset?-- no! just the "NOP" itself takes 1 uop!


    * MOAR TESTS



HARDWARE:

  USE 74HC193 for COUNTERS!!!!

  Remember for designs:
    * Remember, BUS_A and BUS_B should both be pulled low.
    * WE ADDED HARDWARE INC AND DEC COMMANDS TO RSP. AND THE RSP DEC MECHANISM IS COMPLEX, OCCURING A HALF CYCLE BEFORE (check the timings work out).
    * We are hardware latching a mask or something in mod_ctl


  Bugs in current revisions:
  * ALU: the high bits of the switch connecting BUS_B
        to the ALU flags register float!!!!
    ALU: It also has two floating gates!!!

  Improvements future revisions:
  * remove the zero registers from the REG module? (or, can we change the VM code so that we never use a pull-down behaviour?)
  * remote the one register and deal with it in the microcode?---once we fix NEG, we only need REG_ONE for NOT.
    ---much more useful would be a constant=2 reg, we should see where these are and see if we can fix by adding hardware decrements (do these exist?),
       and if they don't maybe consider adding a "2" register.
  * mod_alu: OR and AND are swapped physically on the board vs the mode signal numbers




  Need to think more:
  * Originally improvement thought, but then I remembered:
    mod_mem: allow 1-clock word reads and writes. -> If you have this, you can't write into RA using the address in RA---so forget it?


