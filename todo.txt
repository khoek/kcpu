
SOFT/FIRMWARE:



  REMAINING HARDWARE TO SIMULATE:


    * A jumper/soft flag to issue an NMI after every instruction? (so we can have debugging (over serial?) in the real thing!)



  REMAINING HARDWARE TO FIX/DECIDE:

    * PROHIBIT MOV %rx %rx in hardware? (it would be a short)
            -> The best way to do this is to compute if IU1 == IU2, and if so inhibit the any IU[1/2]_I if there is any IU[1/2]_O asserted.
            -> If we do this, definitely simulate in VM to check implementation!



  Assembler improvements:

    * Allow a const in either argument in e.g. a STW (but not e.g. LDW)

    *  Remove direct access to %rid in the assembler; at the moment the only legitimate usage is saving/restoring in an interrupt handler,
    and in this case we can just roll a custom version of PUSHFG/POPFG to also push/pop it? (actually, there might be
    some problem with decrementing RSP a second time during the push? I think the ALU will be able to do the math
    simultaneously instead?)




  VM UI:
    * Write a post-processor for the disassembler to try to collapse aliases.---this isn't super hard, just search
      for aliases which begin with the first actual opcode, and then continue checking ahead for matches.
            ---> It would probably be best to do this after loading and before executing the binary, so that
                 we don't get confused when we are in the middle of a few instructions all part of the same alias.





  In the VM:

    * Also, for the IO bus use bus hold devices to decouple them, instead of having a silly intermediate IO controller register
  (but remember we want the IO modules to be able to asynchronously call in their results and move on with their lives)

    * FLAG-ONLY versions of the ALU insts (we already value-only versions).

    * Compress ucode! (should we really do this anymore at this point?)



    * MOAR TESTS



HARDWARE:

  USE 74HC193 for COUNTERS!!!!

  Remember for designs:
    * Remember, BUS_A and BUS_B should both be pulled low.
    * WE ADDED HARDWARE INC AND DEC COMMANDS TO RSP. AND THE RSP DEC MECHANISM IS COMPLEX, OCCURING A HALF CYCLE BEFORE (check the timings work out).
    * We are hardware latching a mask or something in mod_ctl


  Bugs in current revisions:
  * ALU: the high bits of the switch connecting BUS_B
        to the ALU flags register float!!!!
    ALU: It also has two floating gates!!!

  Improvements future revisions:
  * remove the zero registers from the REG module? (or, can we change the VM code so that we never use a pull-down behaviour?)
  * remote the one register and deal with it in the microcode?---once we fix NEG, we only need REG_ONE for NOT.
    ---much more useful would be a constant=2 reg, we should see where these are and see if we can fix by adding hardware decrements (do these exist?),
       and if they don't maybe consider adding a "2" register.
  * mod_alu: OR and AND are swapped physically on the board vs the mode signal numbers




  Need to think more:
  * Originally improvement thought, but then I remembered:
    mod_mem: allow 1-clock word reads and writes. -> If you have this, you can't write into RA using the address in RA---so forget it?


